# 创建和更新订单时，如何保证数据准确无误

订单系统是整个电商系统中最重要的一个子系统，订单数据也就是电商企业最重要的数据资产。

一个合格的订单系统，最基本的要求是什么？**数据不能错。**

一个购物流程，从下单开始、支付、发货，直到收货，这么长的一个流程中，每一个环节，都少不了更新订单数据，每一次更新操作又需要同时更新好几张表。这些操作可能被随机分布到很多台服务器上执行，服务器有可能故障，网络有可能出问题。

要会正确地使用数据库的事务。比如，你在创建订单的时候，同时要在订单表和订单商品表中插入数据，那这些插入数据的 INSERT 必须在一个数据库事务中执行，数据库的事务可以确保：执行这些 INSERT 语句，要么一起都成功，要么一起都失败。

## 订单系统的核心功能和数据

我先和你简单梳理一下一个订单系统必备的功能，它包含但远远不限于：

1. 创建订单；
2. 随着购物流程更新订单状态；
3. 查询订单，包括用订单数据生成各种报表。

为了支撑这些必备功能，在数据库中，我们至少需要有这样几张表：

1. **订单主表**：也叫订单表，保存订单的基本信息。
2. **订单商品表**：保存订单中的商品信息。
3. **订单支付表**：保存订单的支付和退款信息。
4. **订单优惠表**：保存订单使用的所有优惠信息。

这几个表之间的关系是这样的：**订单主表和后面的几个子表都是一对多的关系，关联的外键就是订单主表的主键，也就是订单号**。

## 如何避免重复下单

一个订单系统，提供创建订单的 HTTP 接口，用户在浏览器页面上点击“提交订单”按钮的时候，浏览器就会给订单系统发一个创建订单的请求，订单系统的后端服务，在收到请求之后，往数据库的订单表插入一条订单数据，创建订单成功。

假如说，用户点击“创建订单”的按钮时手一抖，点了两下，浏览器发了两个 HTTP 请求，结果是什么？创建了两条一模一样的订单。这样肯定不行，需要做防重。

有的同学会说，前端页面上应该防止用户重复提交表单，你说的没错。但是，网络错误会导致重传，**很多 RPC 框架、网关都会有自动重试机制**，所以对于订单服务来说，重复请求这个事儿，你是没办法完全避免的。

很多电商解决这个问题的思路是这样的。在数据库的最佳实践中有一条就是，数据库的每个表都要有主键，绝大部分数据表都遵循这个最佳实践。一般来说，我们在往数据库插入一条记录的时候，都不提供主键，由数据库在插入的同时自动生成一个主键。这样重复的请求就会导致插入重复数据。

我们知道，表的主键自带唯一约束，如果我们在一条 INSERT 语句中提供了主键，并且这个主键的值在表中已经存在，那这条 INSERT 会执行失败，数据也不会被写入表中。**我们可以利用数据库的这种“主键唯一约束”特性，在插入数据的时候带上主键，来解决创建订单服务的幂等性问题。**

具体的做法是这样的，我们给订单系统增加一个“**生成订单号**”的服务，**这个服务没有参数，返回值就是一个新的、全局唯一的订单号**。**在用户进入创建订单的页面时，前端页面先调用这个生成订单号服务得到一个订单号，在用户提交订单的时候，在创建订单的请求中带着这个订单号**。

这个订单号也是我们订单表的主键，这样，无论是用户手抖，还是各种情况导致的重试，这些重复请求中带的都是同一个订单号。订单服务在订单表中插入数据的时候，**执行的这些重复 INSERT 语句中的主键，也都是同一个订单号**。数据库的唯一约束就可以保证，只有一次 INSERT 语句是执行成功的，这样就实现了创建订单服务幂等性。

幂等创建订单的流程的时序图：

![](https://tva1.sinaimg.cn/large/006DIypxly1h5no1fsbwmj30l90fvac9.jpg)

如果是因为重复订单导致插入订单表失败，订单服务不要把这个错误返回给前端页面。否则，就有可能出现这样的情况：用户点击创建订单按钮后，页面提示创建订单失败，而实际上订单却创建成功了。

## 如何解决 ABA 问题

订单系统各种更新订单的服务一样也要具备幂等性。

这些更新订单服务，比如说支付、发货等等这些步骤中的更新订单操作，最终落到订单库上，都是对订单主表的 UPDATE 操作。数据库的更新操作，本身就具备天然的幂等性，比如说，你把订单状态，从未支付更新成已支付，执行一次和重复执行多次，订单状态都是已支付，不用我们做任何额外的逻辑，这就是天然幂等。

那在实现这些更新订单服务时，需要注意 ABA 问题。

比如说，订单支付之后，小二要发货，发货完成后要填个快递单号。假设说，小二填了一个单号 666，刚填完，发现填错了，赶紧再修改成 888。对订单服务来说，这就是 2 个更新订单的请求。

正常情况下，订单中的快递单号会先更新成 666，再更新成 888，这是没问题的。那不正常情况呢？666 请求到了，单号更新成 666，然后 888 请求到了，单号又更新成 888，**但是 666 更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起 666 请求，单号又被更新成 666 了**。

具体的时序你可以参考下面这张时序图：

![](https://tva1.sinaimg.cn/large/006DIypxly1h5no4glv2sj30lm0gzmzc.jpg)

ABA 问题怎么解决？这里给你提供一个比较通用的解决方法。**给订单主表增加一列，列名可以叫 version，也即是“版本号”的意思。每次查询订单的时候，版本号需要随着订单数据返回给页面。页面在更新数据的请求中，需要把这个版本号作为更新请求的参数，再带回给订单更新服务**。

订单服务在更新数据的时候，**需要比较订单当前数据的版本号，是否和消息中的版本号一致**，如果不一致就拒绝更新数据。**如果版本号一致，还需要再更新数据的同时，把版本号 +1**。**“比较版本号、更新数据和版本号 +1”，这个过程必须在同一个事务里面执行**。

```sql
UPDATE orders set tracking_number = 666, version = version + 1 WHERE version = 8;
```

version 的值需要页面在更新的时候通过请求传进来。

通过这个版本号，就可以保证，从我打开这条订单记录开始，一直到我更新这条订单记录成功，这个期间没有其他人修改过这条订单数据。因为，如果有其他人修改过，数据库中的版本号就会改变，那我的更新操作就不会执行成功。我只能重新查询新版本的订单数据，然后再尝试更新。

有了这个版本号，再回头看一下我们上面那个 ABA 问题的例子，可能出现两种情况：

第一种情况，把运单号更新为 666 的操作了，**更新为 888 的请求带着旧版本号，那就会更新失败，页面提示用户更新 888 失败**。

第二种情况，666 更新成功后，888 带着新的版本号，888 更新成功。**这时候即使重试的 666 请求再来，因为它和上一条 666 请求带着相同的版本号，上一条请求更新成功后，这个版本号已经变了，所以重试请求的更新必然失败**。

无论哪种情况，数据库中的数据与页面上给用户的反馈都是一致的。这样就可以实现幂等更新并且避免了 ABA 问题。下图展示的是第一种情况，第二种情况也是差不多的：

![](https://tva1.sinaimg.cn/large/006DIypxly1h5noa8slkrj30pi0hp0vt.jpg)

## 小结

因为网络、服务器等等这些不确定的因素，重试请求是普遍存在并且不可避免的。具有幂等性的服务可以完美地克服重试导致的数据错误。

对于创建订单服务来说，可以通过预先生成订单号，然后利用数据库中订单号的唯一约束这个特性，避免重复写入订单，实现创建订单服务的幂等性。

对于更新订单服务，可以通过一个版本号机制，每次更新数据前校验版本号，更新数据同时自增版本号，这样的方式，来解决 ABA 问题，确保更新订单服务的幂等性。

## 思考题

- 实现服务幂等的方法，远不止我们这节课上介绍的这两种，在你负责开发的业务系统中，能不能用这节课中讲到的方法来实现幂等？除了这两种方法以外，还有哪些实现服务幂等的方法？
  - 其实总结下来这些实现幂等的方法，无非是两大类：
    - 一类是通过一些精巧的设计让更新本身就是幂等的，这种需要点儿运气，不是所有业务都适用的。
    - 另外，就是利用外部的、具备一致性的存储（比如说MySQL）来做冲突检测，你在设计幂等方法的时候一般都可以顺着这两个思路来开展。
  - 每次请求之前必须先生成一个唯一的请求 id，服务端将该 id 暂时放入 redis。客户端请求时必须携带上这个 id，接口会首先到 redis 中删除该 id，没有的话会返回 0，返回不能重复请求的错误到客户端。用 Redis 集群，数据分片放。
    - 可以提前生成一批ID存到数据库备用，每次请求从sequence表里拿一组id，放到内存，用完了再拿。
- 生成订单号 服务的一般逻辑会是怎样的？思来想去，如果要想这个ID全局唯一，只能带上时间，可是如果带上时间，像那种，不小心点了两次按钮的情况，必然是两个不同的订单号；请问这个问题怎么解决？
  - 生成订单号的时机，是在进入订单页面，而不是提交订单的时候，先拿到订单号，才会展示提交按钮。
- 生成全局唯一订单号如果不是自增的，插入mysql innodb表的时候，底层的B+树索引是不是会发生页分裂等问题，影响插入性能？如果遇到大促，短时间生成大量订单，写入会成为瓶颈不？
  - 这确实是一个需要考虑的性能问题。 所以很多业务在设计订单号规则的时候都不是完全随机的，一般都是递增的。这种情况下，页分裂就不会特别严重。
  - 订单号设为唯一索引约束即可，仍然有个自增主键，订单号对外用，主键不暴露，这样表空间还是紧密的，其他关联订单表仍然以订单号作外键。
- 假设666前面还有个更新555的操作，且当下数据库负载高处理比较慢，那么666的更新操作和888的更新操作就可能同时等待555的操作结束，这时候666和888谁先执行就不一定了，是可能888的操作先开启事务的。（也可能666操作路由到服务器负载高导致执行延后，888路由到的服务器直接执行，这样888也会在前面。）（假设两个操作在同个进程里面执行，666的线程a和888的线程b谁先走到数据库开启事务这一步也不是一定的，仍然有可能888的线程b先到）。
  - 时间戳？
- 像订单表这类型的表，有个ID，还有个订单号，还有其他字段，如果我其他表要关联这个订单表，是关联订单ID好，还是关联订单号比较好呢？比如我的支付信息表。
  - 很多系统的做法是，订单号就是主键。 如果订单号不是主键，一般有业务含义的关联还是用订单号。
  - 订单编号不是主键的时候，如果用订单id做关联，后面分库分表的就不好玩了。
- 加锁也是一种不错的方法，处理好锁的粒度和竞争。
  - 锁的话如果时多节点也没办法，得用分布式锁。
- 我们目前对重复下单不做处理， 过期不支付的话就把该订单关闭了， 加上我们目前不会把订单展示给用户， 似乎没啥问题。
  - 重复下单还是要处理下，有很多监听创建订单的事件触发，比如发通知消息、增加积分，都会有影响。
  - 后期做报表的话，感觉数据有点乱，不容易跟踪分析用户行为吧？比如到底是真下单不付款还是重复下单了。
- 用户如果对这个页面不小心同时开了多个tab页，每次打开一个tab页都会生成个新订单号，那就可以提交多个“一模一样”的订单了，而且用户本意应该是一个订单。 怎么看待这个问题？
  - 如果用户打开了多个tab页，只会产生多个订单号，这个时候还没有生成新订单呢。 只有他在每个tab也都点“下单”按钮，才会产生多个订单。这种情况不存在“误操作”的可能了。
- 使用购物车 id 和 购物车状态。
- 无论采用哪种生成订单id的方式，短时间内都可能出现靠前的id后提交（生成订单的问题)，这样一定程度上数据库接收到的id不是严格按时间递增的。而页面浏览的场景，尤甚。 请问这会带来一定程度上的性能下降嘛？
  - 所有的BTree索引都会有页分裂的问题, 在order id上加unique key性能跟普通索引没什么区别。
  - order id不可能完全自增, 但可以尽可能的伪自增. 实际上MySQL的自增主键也不是严格自增的。
  - 主键使用自增ID，订单号建立唯一索引能否解决呢？
    - 唯一索引不太行，订单如果在多个数据库可能会出现重复的问题。