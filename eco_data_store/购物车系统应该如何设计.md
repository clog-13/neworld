# 购物车系统，应该如何设计？

购物车对数据可靠性要求不高，性能也没有特别的要求。

购物车系统的功能，主要的就三个：把商品加入购物车（后文称“加购”）、购物车列表页、发起结算下单，再加上一个在所有界面都要显示的购物车小图标。

支撑购物车的这几个功能，对应的存储模型应该怎么设计？很简单，只要一个“购物车”实体就够了。它的主要属性有什么？你打开京东的购物车页面，对着抄就设计出来了：**SKUID（商品 ID）、数量、加购时间和勾选状态**。

这个“勾选状态”属性，就是在购物车界面中，每件商品前面的那个小对号，表示在结算下单时，是不是要包含这件商品。至于商品价格和总价、商品介绍等等这些信息，都可以实时从其他系统中获取，不需要购物车系统来保存。

## 设计购物车存储时需要把握什么原则？

比如下面这几个问题：

1. **用户没登录，在浏览器中加购，关闭浏览器再打开，刚才加购的商品还在不在**？

2. **用户没登录，在浏览器中加购，然后登录，刚才加购的商品还在不在**？
3. **关闭浏览器再打开，上一步加购的商品在不在**？
4. **再打开手机，用相同的用户登录，第二步加购的商品还在不在呢**？

如果用户没登录，加购的商品也会被保存在用户的电脑里，这样即使关闭浏览器再打开，购物车的商品仍然存在。

如果用户先加购，再登录，登录前加购的商品就会被自动合并到用户名下，所以登录后购物车中仍然有登录前加购的商品。

关闭浏览器再打开，这时又变为未登录状态，但是之前未登录时加购的商品已经被合并到刚刚登录的用户名下了，所以购物车是空的。

使用手机登录相同的用户，看到的就是该用户的购物车，这时无论你在手机 App、电脑还是微信中登录，只要是相同的用户，看到是同一个购物车，所以第二步加购的商品是存在的。

所以，上面这四个问题的答案依次是：**存在、存在、不存在、存在**。

要解决上面这些问题，其实只要在存储设计时，把握这几个原则就可以了：

1. 如果未登录，需要临时暂存购物车的商品；
2. 用户登录时，把暂存购物车的商品合并到用户购物车中，并且清除暂存购物车；
3. 用户登陆后，购物车中的商品，需要在浏览器、手机 APP 和微信等等这些终端中都保持同步。

购物车系统需要保存两类购物车，**一类是未登录情况下的“暂存购物车”，一类是登录后的“用户购物车”**。

## 如何设计“暂存购物车”的存储？

暂存购物车应该存在客户端还是存在服务端？

如果保存在服务端，那每个暂存购物车都需要有一个全局唯一的标识，这个标识并不太容易设计，并且，存在服务端还要浪费服务端的资源。所以，肯定是保存在客户端好，既可以节约服务器的存储资源，也没有购物车标识的问题，因为每个客户端就保存它自己唯一一个购物车就可以了，不需要标识。

客户端的存储可以选择的不太多：**Session、Cookie 和 LocalStorage**，其中浏览器的 LocalStorage 和 App 的本地存储是类似的，我们都以 LocalStorage 来代表。

存在哪儿最合适？SESSION 是不太合适的，原因是，SESSION 的保留时间短，而且 SESSION 的数据实际上还是保存在服务端的。

Cookie 和 LocalStorage 都可以用来保存购物车数据，各有优劣。

在我们这个场景中，使用 Cookie 和 LocalStorage 最关键的区别是，客户端和服务端的每次交互，都会自动带着 Cookie 数据往返，这样服务端可以读写客户端 Cookie 中的数据，**而 LocalStorage 里的数据，只能由客户端来访问**。

使用 Cookie 存储，实现起来比较简单，加减购物车、合并购物车的过程中，由于服务端可以读写 Cookie，这样全部逻辑都可以在服务端实现，并且客户端和服务端请求的次数也相对少一些。

使用 LocalStorage 存储，实现相对就复杂一点儿，客户端和服务端都要实现一些业务逻辑，但 LocalStorage 的好处是，它的存储容量比 Cookie 的 4KB 上限要大得多，而且不用像 Cookie 那样，无论用不用，每次请求都要带着，可以节省带宽。

所以，选择 Cookie 或者是 LocalStorage 来存储暂存购物车都是没问题的，你可以根据它俩各自的优劣势来选择。比如你设计的是个小型电商，那用 Cookie 存储实现起来更简单。再比如，你的电商是面那种批发的行业用户，用户需要加购大量的商品，那 Cookie 可能容量不够用，选择 LocalStorage 就更合适。

不管选择哪种存储，暂存购物车保存的数据格式都是一样的，参照我们实体模型来设计就可以，我们可以直接用 JSON 表示：

```json
{
    "cart": [
        {
            "SKUID": 8888,
            "timestamp": 1578721136,
            "count": 1,
            "selected": true
        },
        {
            "SKUID": 6666,
            "timestamp": 1578721138,
            "count": 2,
            "selected": false
        }
    ]
}
```

## 如何设计“用户购物车”的存储？

因为用户购物车必须要保证多端的数据同步，所以数据必须保存在服务端。常规的思路是，设计一张购物车表，把数据存在 MySQL 中。

不同尺寸的同种商品每个都有独立的ID：

![](https://tva1.sinaimg.cn/large/006DIypxly1h5nll3gt8wj30nr09xju5.jpg)

**需要在 user_id 上建一个索引**，因为查询购物车表时，都是以 user_id 作为查询条件来查询的。

你也可以选择更快的 Redis 来保存购物车数据，以用户 ID 作为 Key，用一个 Redis 的 HASH 作为 Value 来保存购物车中的商品。比如：

```json
{
    "KEY": 6666,
    "VALUE": [
        {
            "FIELD": 8888,
            "FIELD_VALUE": {
                "timestamp": 1578721136,
                "count": 1,
                "selected": true
            }
        },
        {
            "FIELD": 6666,
            "FIELD_VALUE": {
                "timestamp": 1578721138,
                "count": 2,
                "selected": false
            }
        }
    ]
}
```

使用 Redis 性能要比 MySQL 高出至少一个量级，响应时间更短，可以支撑更多的并发请求，“天下武功，唯快不破”，这一点 Redis 完胜。

MySQL 的数据可靠性是要好于 Redis 的，因为 Redis 是**异步刷盘**，如果出现服务器掉电等异常情况，Redis 是有可能会丢数据的。但考虑到购物车里的数据，对可靠性要求也没那么苛刻，丢少量数据的后果也就是，个别用户的购物车少了几件商品，问题也不大。所以，在购物车这个场景下，Redis 的数据可靠性不高这个缺点，并不是不能接受的。

MySQL 的另一个优势是，它支持丰富的查询方式和事务机制，这两个特性，对我们今天讨论的这几个购物车核心功能没什么用。但是，每一个电商系统都有它个性化的需求，如果需要以其他方式访问购物车的数据，比如说，统计一下今天加购的商品总数，这个时候，使用 MySQL 存储数据，就很容易实现，而使用 Redis 存储，查询起来就非常麻烦而且低效。

综合比较下来，考虑到需求总是不断变化，还是更推荐你使用 MySQL 来存储购物车数据。如果追求性能或者高并发，也可以选择使用 Redis。

你可以感受到，我们设计存储架构的过程就是一个不断做选择题的过程。很多情况下，可供选择的方案不止一套，选择的时候需要考虑实现复杂度、性能、系统可用性、数据可靠性、可扩展性等等非常多的条件。需要强调的是，**这些条件每一个都不是绝对不可以牺牲的，不要让一些“所谓的常识”禁锢了你的思维。**

## 思考题

- 既然用户的购物车数据存放在 MySQL 或者是 Redis 中各有优劣势。那能不能把购物车数据存在 MySQL 中，并且用 Redis 来做缓存呢？如果可行，如何来保证 Redis 中的数据和 MySQL 中的数据是一样的呢？
  - 用Redis给购物车库做缓存，技术上肯定是可行的。但是有两个问题需要思考一下。
    -  第一个问题是，值不值得这样做？因为每个人的购物车都是不一样的，所以这个缓存它的读写比差距不会很大，缓存的命中率不会太高，缓存的收益有限，为了维护缓存，还要增加系统的复杂度。所以我们就要自行权衡一下，是不是值得的问题。我的观点是，除了超大规模的系统以外，没有必要设置这个缓存。 
    - 第二个问题是，如果我们非要做这样一个缓存，用什么缓存更新策略更好呢？
  - 读多写少用缓存，写多读少用MQ。
  - 每个人都购物车都是独立的商品组合，每个用户的数据是隔离的，只访问自己的数据，缓存命中率太低，完全没有达到缓存的目的。
- 加上未登陆添加购物车的功能。在当下，可能是牺牲部份可能发展成活跃用户的流动用户，来换取微末的用户体验。得不偿失。
- 每次加完购物车都要跳转到一个中转界面上呢？
  - 局外人的猜测是，加购之后，一般用户就不会想继续看这个商详页了，接下来它可能的二个路径是： 1.去购物车结算； 2.去看其它商品；增加一个中间页，可以放好多推荐商品，引导用户继续购物。
- **购物车的表设计，其主键id是否可以用user_id+sku_id的拼接字符串**？相对于老师的示例表结构，应该有如下优点： 1. 节省存储空间占用、加速写入：因为不需要为这个表以user_id建立二级索引了，这个表可以没有索引，省去了一些存储空间和写入消耗。 2. 加速读取：因为主键的前一部分是user_id，那么前缀相同每个user的购物车数据一定是存储在一起的，那么每次读取同一个user的购物车，都只需要一次顺序读，比起通过二级索引查到user_id的购物车数据，再回表随机读会更快。
  - 如果是拼接作为主键的话，主键肯定是字符串了，因为需要分隔符来避免歧义，字符串作为主键，插入时会索引会重新排序。
  - MySQL是B+tree。LSM Tree因此没有插入会导致页分裂的问题。
- 暂存购物车写到Cookie中，是不需要标识的，因为Cookie是存在浏览器中的，每个浏览器本身就是标识。 另外，Cookie也是可以设定有效期的。