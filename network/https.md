# 安全篇

**特性：**机密性、完整性，身份认证和不可否认。

- 机密性（Secrecy/Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。
- 完整性（Integrity，也叫一致性）是指数据在传输过程中没有被篡改，不多也不少，“完完整整”地保持着原状。
- 身份认证（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。
- 不可否认（Non-repudiation/Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”。

## HTTPS

默认端口号 443，除了协议名“http” 和 端口号80这两点不同，HTTPS 协议在语法、语义上和 HTTP 完全一样，优缺点也“照单全收”（当然要除去**“明文”和“不安全”**）。

HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上（可参考第 4 讲和第 5 讲），收发报文不再使用 Socket API，而是调用专门的安全接口。

![img](https://static001.geekbang.org/resource/image/50/a3/50d57e18813e18270747806d5d73f0a3.png?wh=2057*810)

## SSL/TLS

SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层）。

SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。

TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。

TLS 的密码套件命名基本的形式是**“密钥交换算法（通信双方通过非对称加密协商出一个用于对称加密的密钥） + 签名算法（身份认证，不可否认） + 对称加密算法（机密性） + 摘要算法（完整性）”**。

**ECDHE-RSA-AES256-GCM-SHA384：**握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。

除了HTTP，SSL/TLS也可以承载其他的应用协议，例如FTP=>FTPS,LDAP=>LDAPS等。

## OpenSSL

OpenSSL，它是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。

OpenSSL里的密码套件定义与 TLS略有不同，TLS里的形式是“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”，加了前缀“TLS”，并用“WITH”分开了握手和通信的算法。

在OpenSSL1.0.1版本中存在严重漏洞（CVE-2014-0160），此次漏洞问题存在于ssl/dl_both.c文件中。

**“心脏出血”：**OpenSSL 有一个叫 Heartbeat （心跳检测）的拓展，问题就出在这个拓展上，这也是漏洞被命名为“心脏出血”的直接原因。

所谓心跳检测，就是建立一个 Client Hello 问询来检测对方服务器是不是正常在线 ，服务器发回 Server hello，表明正常树立SSL通讯。就像我们打电话时会问对方 “喂听得到吗？”一样。

每次问询都会附加一个问询的字符长度 pad length，bug 来了，如果这个 pad length 大于实际的长度，服务器仍是会回来相同规模的字符信息，于是形成了内存里信息的越界访问。 

就这样，每发起一个心跳，服务器就能泄露一点点数据（理论上最多泄露 64K），这些数据里可能包括用户的登录账号密码、电子邮件甚至是加密秘钥等信息，也可能并没有包含这些信息，但攻击者可以不断利用 “心跳”来获取更多的信息。就这样，服务器一点一点泄露越来越多的信息，就像是心脏慢慢在出血，心脏出血漏洞的名字由此而来。

## Q&A 证书

Q：之前调用第三方的支付走https协议都需要本地配置一个证书。为啥最近有个项目也是用的https协议(url里会放token)。直接和http一样调用就好了，不需要本地配置证书了呢？

A：本地证书是用来做双向认证的，服务器用客户端的证书来验证客户端的证书。 通常我们上网是单向认证，只验证服务器的身份，客户端（也就是用户）的身份不用证书验证。

## 对称加密

**AES** 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化。

**ChaCha20** 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错的算法。

严格来说对称加密算法还可以分为**块加密算法(block cipher)**和**流加密算法(stream cipher)**，DES、AES等属于块加密，而RC4、ChaCha20属于流加密。

## 加密分组模式

对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。

最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。

把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。

**AES128-GCM：**意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM。

**ChaCha20-Poly1305：**的意思是 ChaCha20 算法，使用的分组模式是 Poly1305。

## 非对称加密

**RSA** 可能是其中最著名的一个，10 年前 RSA 密钥的推荐长度是 1024，但随着计算机运算能力的提高，现在普遍认为至少要 2048 位。

**ECC（Elliptic Curve Cryptography）** 基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，

子算法 **ECDHE** 用于密钥交换，**ECDSA** 用于数字签名。目前比较常用的两个曲线是 **P-256**（secp256r1，在 OpenSSL 称为 prime256v1）和 **x25519**。P-256 是 NIST（美国国家标准技术研究所）和 NSA（美国国家安全局）推荐使用的曲线，而 x25519 被认为是最安全、最快速的曲线。ECC 名字里的“椭圆”经常会引起误解，其实它的曲线并不是椭圆形，只是因为方程很类似计算椭圆周长的公式，实际的形状更像抛物线。

比起 RSA，**ECC 在安全强度和性能上都有明显的优势**。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的 RSA。

ECC虽然定义了公钥和私钥，但不能直接实现密钥交换和身份认证，需要搭配DH、DSA等算法，形成专门的 ECDHE、ECDSA。RSA比较特殊，本身即支持密钥交换也支持身份认证。

比特币、以太坊等区块链技术里也用到了ECC，它们选择的曲线是 **secp256k1**。

## Q&A 非对称加密缺点 私钥作用

Q：非对称加密除了慢外还有什么缺点？

A：非对称加密基于大数运算，比如大素数或者椭圆曲线，是复杂的数学难题，所以消耗计算量，运算速度慢。 

需要更多的位数，相同强度的对称密钥要比非对称密钥短。 对称密钥一般都128位、256位，而rsa一般要2048位，不过椭圆曲线的会短一点。

还有一个担忧，这些数学难题可能将来有一天就不再是难题了，那非对称加密就土崩瓦解了。

Q：私钥加密后任何人都可以用公钥解密，这有什么用呢？

A：私钥加密用公钥解是为了私钥加密用公钥解是为了**做身份认证，不可抵赖**，因为默认私钥只有持有人知道，因为默认私钥只有持有人知道。

## 摘要算法

实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。

可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。

摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，存在“冲突”（collision，也叫碰撞）的可能性。

摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数（PRF，pseudo random function）。

目前 TLS 推荐使用 SHA-2。SHA-2 是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。

## 完整性

摘要算法保证了“数字摘要”和原文是完全等价的。只要在原文后附上它的摘要，就能够保证数据的完整性。

摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。所以，**真正的完整性必须要建立在机密性之上**，在混合加密系统里用会话密钥加密消息和摘要。这有个术语，叫**哈希消息认证码（HMAC）**。

## 数字签名

