# HTTP的实体数据

## 数据类型与编码

在 TCP/IP 协议栈里，传输数据基本上都是“header+body”的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。

而 HTTP 协议则不同，它是应用层的协议，数据到达之后还必须要告诉上层应用这是什么数据。假如 HTTP 没有告知数据类型的功能，服务器把“一大坨”数据发给了浏览器，浏览器看到的是一个“黑盒子”，这时候该怎么办呢？当然，它可以“猜”。因为很多数据都是有固定格式的，所以通过检查数据的前几个字节也许就能知道这是个 GIF 图片、或者是个 MP3 音乐文件，但这种方式十分低效，而且有很大几率会检查不出来文件类型。

在 HTTP 协议诞生之前，在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 **MIME**。

MIME 是一个很大的标准规范，HTTP 只取了其中的一部分，用来标记 body 的数据类型，这就是“**MIME type**”。**MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串**。

**text**：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。

**image**：即图像文件，有 image/gif、image/jpeg、image/png 等。

**audio/video**：音频和视频数据，例如 audio/mpeg、video/mp4 等。

application：数据格式不固定，**可能是文本也可能是二进制**，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，就会是 application/octet-stream，即不透明的二进制数据。

仅有 MIME type 还不够，HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“**Encoding type**”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。

Encoding type 常用的有下面三种：

**gzip**：GNU zip 压缩格式，也是互联网上最流行的压缩格式；

**deflate**：zlib（deflate）压缩格式，流行程度仅次于 gzip；

**br**：一种**专门为 HTTP 优化的新压缩算法（Brotli）**。

## 数据类型使用的头字段

有了 MIME type 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了。**HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“内容协商”**。

![](https://tva1.sinaimg.cn/large/006DIypxly1h5gnkhk0loj31jk0v514h.jpg)

**Accept** 字段标记的是**客户端**可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：

```
Accept: text/html,application/xml,image/webp,image/png
```

这就是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。

相应的，**服务器**会在响应报文里用头字段 **Content-Type** 告诉实体数据的真实类型：

```
Content-Type: text/htmlContent-Type: image/png
```

这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。

**Accept-Encoding** 字段标记的是**客户端**支持的压缩格式，可以用“,”列出多个，服务器可以选择其中一种来压缩数据，**实际使用的压缩格式放在响应头字段 Content-Encoding 里**。

**如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩**。

## 语言类型与编码

不同国家不同地区的人使用了很多不同的语言，虽然都是 text/html，但如何让浏览器显示出每个人都可理解可阅读的语言文字呢？HTTP 采用了与数据类型相似的解决方案，又引入了两个概念：**语言类型与字符集**。“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言。

在需要明确区分的时候也要使用“**type-subtype**”的形式，不过这里的格式与数据类型不同，**分隔符不是“/”，而是“-”**。

例子：en 表示**任意的英语**，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语。

关于自然语言的计算机处理还有一个更麻烦的东西叫做“**字符集**”。在计算机发展的早期，各个国家和地区的人们“各自为政”，发明了许多字符编码方式来处理文字，比如英语世界用的 ASCII、汉语世界用的 GBK、BIG5，日语世界用的 Shift_JIS 等。同样的一段文字，用一种编码显示正常，换另一种编码后可能就会变得一团糟。

Unicode 和 UTF-8 把世界上所有的语言都容纳在一种编码方案里，遵循 UTF-8 **字符编码方式**的 Unicode **字符集**也成为了互联网上的标准字符集。

## 语言类型使用的头字段

同样的，HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言与编码进行“内容协商”。

![](https://tva1.sinaimg.cn/large/006DIypxly1h5gnw04j2zj31jk0v5qes.jpg)

**Accept-Language** 字段标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：

```
Accept-Language: zh-CN, zh, en
```

这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。

相应的，服务器应该在响应报文里用头字段 **Content-Language** 告诉客户端实体数据使用的实际语言类型：

```
Content-Language: zh-CN
```

字符集在 HTTP 里使用的请求头字段是 **Accept-Charset**，但却没有对应的响应头，**而是在 Content-Type 字段的数据类型后面用“charset=xxx”来表示**。

例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样：

```
Accept-Charset: gbk, utf-8
Content-Type: text/html; charset=utf-8
```

不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 Content-Language，因为**使用的语言完全可以由字符集推断出来**，**所以在请求头里一般只会有 Accept-Language 字段，响应头里只会有 Content-Type 字段**。

## 内容协商的质量值

在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。

权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。

具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里“;”的意义是小于“,”的。例如下面的 Accept 字段：

```
Accept: text/html,application/xml;q=0.9,*/*;q=0.8
```

它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，**最后是任意数据类型**，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。

## 内容协商的结果

内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在**响应头**里多加一个 **Vary** 字段，**记录服务器在内容协商时参考的请求头字段，给出一点信息**，例如：

```
Vary: Accept-Encoding,User-Agent,Accept
```

这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，**然后决定了发回的响应报文**。Vary 字段可以认为是响应报文的一个特殊的“版本标记”。**每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化**。也就是说，**同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务**。

![](https://tva1.sinaimg.cn/large/006DIypxly1h5gpjl471ij31jk0s1n63.jpg)

## 小结

- **数据类型**表示实体数据的**内容是什么**，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；

- **数据编码**表示实体数据的**压缩方式**，相关的头字段是 Accept-Encoding 和 Content-Encoding；

- **语言类型**表示实体数据的**自然语言**，相关的头字段是 Accept-Language 和 Content-Language；

- **字符集**表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；

- 客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；

- Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。

##  Q&A

- content-type是实体字段，所以请求和响应里都可以用，作用是指明body数据的类型。比如：上传图片时候客户端需要设置content-type:"image/jpg"。不然如果使用上传的js-sdk设置的默认类型：content-type:"octet-stream"，那么浏览器就不认识这个图片了，转而会下载这个文件(图片)。
- 每一个并发连接，都需要新建tcp三次握手吗？还是一次tcp握手后，可以并发多个连接？
  -  每建立一个连接就需要tcp握手，对同一个ip地址+端口，浏览器通常最多建立6个并发连接（rfc 的规定）。
- 现在很多小文件，比如 图片 都往云存上放了，千万指定正确content-type，一旦指定错，批量修改太麻烦，而且会影响终端的解析。
- post和get时都可以使用Accept-Language，表示客户端可以理解的语言，要求服务器按照指示返回数据。 Content-Language表示的是body数据的语言，因为post带有body，所以要用Content-Language来告诉服务器，报文的body是什么。 如果get报文也有body，那么它也可以使用Content-Language。`Content-`表示提供的具体信息，由于客户端与服务端都可以提供信息，所以`Content-`是可以在两端都可以用的。
- Accept-Language是请求头字段，只要是发请求就可以带。 Content-Language是实体头字段，只要是有body就可以带。
- 文件上传的大小限制都是有哪些限制或控制？发现有些框架默认只能是2g
  - http协议对大小没有限制，这些应该都是网站服务器做的限制，比如Nginx就可以设置client body的大小。
- charset不能同时使用两种编码。

# HTTP传输大文件

## 数据压缩

gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。

不过数据压缩在处理文本的时候效果还是很好的，所以各大网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。

## 分块传输

分块传输的思路在 HTTP 协议里就是“chunked”分块传输编码，在 **响应报文** 里用头字段 “**Transfer-Encoding: chunked**” 来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“Content-Length”里给出确切的长度，所以也只能用 chunked 方式分块发送。

“Transfer-Encoding: chunked” 和 “Content-Length” 这两个字段是互斥的，响应报文里这两个字段不能同时出现。

分块传输的编码规则同样采用了明文的方式，很类似响应头。**每个分块包含两个部分，长度头和数据块；长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF**；最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。

![](https://tva1.sinaimg.cn/large/006DIypxly1h5gqd6l291j32bc1ap4ar.jpg)

浏览器在收到分块传输的数据后会自动按照规则去掉分块编码，重新组装出内容，想要看到服务器发出的原始报文形态得用 Telnet 手工发送请求（或者用 Wireshark 抓包）

## 范围请求

比如，你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据。

HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分。

范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以**服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端”**，如果不支持的话服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段，这样客户端就认为服务器没有实现范围请求功能。

请求头 Range 是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以**字节**为单位的数据范围。要注意 x、y 表示的是“**偏移量**”，**范围必须从 0 计数**。起点 x 和终点 y 可以省略：“0-”表示从文档起点到文档终点；“10-”是从第 10 个字节开始到文档末尾；“-1”是文档的最后一个字节；“-10”是从文档末尾倒数 10 个字节。

服务器收到 Range 字段后，需要做四件事：

第一，它必须检查范围是否合法，如果范围越界了。服务器就会返回状态码 **416**。

第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“**206 Partial Content**”，表示 body 只是原数据的一部分。

第三，服务器要添加一个响应头字段 Content-Range，告诉片段的实际偏移量和资源的总大小，格式是“bytes x-y/length”，与 Range 头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。

第四，发送数据，直接把片段用 TCP 发给客户端，一个范围请求就算是处理完了。

有了范围请求之后，HTTP 处理大文件就更加轻松了，看视频时可以根据时间点计算出文件的 Range，不用下载整个文件，直接精确获取片段所在的数据内容。不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：

- 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；
- 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；
- 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。

## 多段数据

还可以在 Range 头里使用多个“x-y”，一次性获取多个片段数据。

这种情况需要使用一种**特殊的 MIME 类型：“multipart/byteranges”**，表示报文的 body 是由多段字节序列组成的，**用一个参数“boundary=xxx”给出段之间的分隔标记**。多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段。

![](https://tva1.sinaimg.cn/large/006DIypxly1h5gr38hr21j32bc1apqld.jpg)

**每一个分段必须以“- -boundary”开始**（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，**最后用一个“- -boundary- -”**（前后各有两个“-”）表示所有的分段结束。

例如：

```
GET /16-2 HTTP/1.1
Host: www.chrono.com
Range: bytes=0-9, 20-29
```

```
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes

--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96

// this is
--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96

ext json d
--00000000001--
```

报文里的“- -00000000001”就是多段的分隔符。

## 小结

- 压缩 HTML 等文本文件是传输大文件最基本的方法；分块传输可以流式收发数据，节约内存和带宽，使用**响应头字段“Transfer-Encoding: chunked“**来表示，**分块的格式是 16 进制长度头 + 数据块**；
- 范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用**请求头字段“Range”**和**响应头字段“Content-Range”**，响应状态码必须是 **206**；
- 也可以一次请求多个范围，这时候**响应报文的数据类型是“multipart/byteranges”**，body 里的多个部分会用 boundary 字符串分隔。
- 这四种方法不是互斥的，而是可以混合起来使用，例如**压缩后再分块传输**，或者**分段后再分块**。
- gzip 的压缩率通常能够超过60%，**br算法是专为HTML设计的**，压缩效率和性能比 gzip还要好，能够再提高20%的压缩密度。
- Nginx的“gzip on”指令很智能，只会压缩文本数据，不会压缩图片、音频、视频。
- Transfer-Encoding字段最常见的值是chunked，但也可以用gzip、deflate 等，表示传输时使用了压缩编码。**Transfer-Encoding在传输后会被自动解码还原出原始数据，而 Content-Encoding 则必须由应用自行解码。**
- 分块传输在末尾还允许有“拖尾数据”，由**响应头字段”Trailer“**指定。
- 与Range有关的还有一个If-Range，即条件范围请求，与缓存有关。

## Q&A

- 分块传输数据的时候，如果数据里含有回车换行（\r\n）是否会影响分块的处理呢？
  - 不影响分块处理，因为分块前有数据长度说明。
- 如果对一个被 gzip 的文件执行范围请求，比如“Range: bytes=10-19”，那么这个范围是应用于原文件还是压缩后的文件呢？
  - 分情况，看原文件是什么形式。如果原来的文件是gzip的，那就应用于压缩后的文件。如果原文件是文本，而在传输过程中被压缩，那么就应用于压缩前的数据。
- chunk只是在传输过程中分块，最后到客户端会是一个完整的文件。

- 分块传输，客户端只需要发一次请求，还是发多次请求呢？使用分块传输时，客户端与服务器是怎样工作的？
  - http传输永远是一个请求一个响应的工作模式，一个http请求必定是在一个tcp连接里收发的。 虽然是分块，但也是用一个tcp。只是响应是chunked分块，body数据不是一次性发过来的，而是分批分块发送，**但仍然是在一个报文里**。 客户端发送请求后等待响应，服务器组织数据，分块发送，最后一个分块是结束标志。客户端依次接收分块，**收到结束标志后就把数据拼成完整的报文**。
- 客户端上传的时候也可以用chunked、gzip，但不能用range。
- 分块：http把客户端需要的东西切分成1、2、3到n块，然后将1块发给tcp，tcp将块1再次切分后发给客户端，客户端接受后在tcp组装成块1发给http层。然后服务器与客户端用同样的方式发送块2、块3到块n。客户端的http在接收完所有块后组装成一个完整的响应。整个过程使用同一个tcp连接，块1到块n如上是挨个发送的。**如果是http2，则基于多路复用技术块1到块n可以同时发送**。**所以分块抓包http只能抓到一个包，如果抓tcp的包，分不分块，都会抓到很多包。**
- 如果Content-Length是0，报文里也可以有body，但因为头里指定长度为0，所以服务器就会忽略body，也不能算是错误报文。
- 如果不显式设置Content-Length，有的框架会自动填写这个字段，或者就变成了chunked格式。
- HTTP 没有校验功能，只使用偏移量来拼接块。
- 处理chunked数据其实就是处理字符串，因为chunked格式很清晰，可以正则。
- 在一个TCP连接中，①大文件分片后，对多个文件片进行并发上传（在一个TCP连接中多个http是排队处理的），与②对一个大文件上传，①②速度上有区别吗？
  - **在http/1.1里是不能并发上传的，只能串行。 1/2两种情况速度上没区别，但整个大文件传输会占用很多内存**。
- 使用chunk分段后还能压缩吗？或者说chunk分段分的是压缩后还是压缩前的文件呢？
  - 可以的，先压缩再分块。
- 使用了chunk，为什么内存、带宽会节省呢？总的数据大小不变吧？内存的话，分段后，前面的数据到达浏览器客户端后，是存在内存还是磁盘呢？如何节省内存呢?
  -  分块的好处是每次只处理一小部分数据，比如一次只从磁盘读取10k，而不用把1G的文件都读进内存，发的时候也可以慢慢发，所以就节省了内存、带宽，对方收到数据肯定是先在内存里，之后可以用各种策略，比如达到一定的大小（比如1M）就落盘存。
- web客户端可以分批上传一个大文件的功能吗？类似于云盘中的上传功能。
  - 上传就要用chunked功能，流式发送数据，服务器流式接收数据。 **range功能只能是下载用，不能上传**。

# HTTP的连接管理

## 短连接

HTTP 协议最初（0.9/1.0）通信过程采用了简单的“请求 - 应答”方式。

它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接，称为“**短连接**”（short-lived connections）。早期的 HTTP 协议也被称为是“**无连接**”的协议。

短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 **1 个 RTT**；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。

## 长连接

针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。

## 连接相关的头字段

在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接。

也可以在请求头里明确地要求使用长连接机制，使用字段“Connection: keep-alive”。不过不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“Connection: keep-alive”字段，告诉客户端：“我是支持长连接的，接下来就用这个 TCP 一直收发数据吧”。

![](https://tva1.sinaimg.cn/large/006DIypxly1h5gu9pfjbgj30vq0bvn0u.jpg)

不过长连接也有一些小缺点。因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。

所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。

在客户端，可以在请求头里加上“Connection: close”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。

服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。

另外，客户端和服务器都可以在报文里附加通用头字段“Keep-Alive: timeout=value”，限定长连接的超时时间。但这个字段的约束力并不强，通信的双方可能并不会遵守，所以不太常见。

## 队头阻塞（Head-of-line blocking，也叫“队首阻塞”）

“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。

因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。

性能优化因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数 就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。RFC2616 里明确限制每个客户端最多并发 2 个连接。不过实践证明这个数字实在是太小了，众多浏览器都“无视”标准，把这个上限提高到了 6~8。

“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。HTTP 协议和浏览器限制并发连接数量吗。那就多开几个域名，比 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 `www.chrono.com`。

## 小结

- HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应；
- 服务器会发送“Connection: keep-alive”字段表示启用了长连接；
- 报文头里如果有“Connection: close”就意味着长连接即将关闭；
- 过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；
- “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。